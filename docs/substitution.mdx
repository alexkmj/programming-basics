# Substitution

Substitutability is an important concept in Object-Oriented Programming (OOP)
that refers to the ability of a derived class or subclass to be used in place of
its base class or superclass without causing errors or unexpected behavior in
the program.

In OOP, inheritance allows a class to inherit the properties and behaviors of
its parent class. A subclass can override or add to the functionality of the
parent class, but it must also be able to be used in place of the parent class.

Substitutability ensures that any code written for the parent class can also
work seamlessly with objects of the subclass. This is important for writing
modular and reusable code, as it allows different classes to be substituted for
each other without requiring any changes to the code that uses them.

For example, consider a program that has a class called Animal, with a method
called `makeSound()`. The program also has two subclasses, Cat and Dog, that
inherit from Animal and override the `makeSound()` method to produce the sound
of a cat or dog, respectively.

If the program has a function that takes an Animal object as a parameter, any
instance of Cat or Dog can be passed to that function, as they are both Animal
objects and can be substituted for each other without causing any issues.

Substitutability is closely related to the Liskov substitution principle, which
states that if a program is using a base class, it should be able to use any of
its derived classes without knowing it. This principle helps ensure that the
derived classes adhere to the same contract as the base class, and that they do
not introduce new requirements or behaviors that could cause issues when
substituted for the base class.

```java
// Base class
class Animal {
    public void eat() {
        System.out.println("Eating...");
    }
}

// Derived class
class Dog extends Animal {
    public void bark() {
        System.out.println("Barking...");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat();
        dog.bark();
    }
}
```

```java
Dog husky = new Dog();
Animal anotherHusky = husky;
husky.bark();
```

```java
Animal husky = new Dog();
Dog anotherHusky = (Dog) husky;
husky.bark();

Animal poodle = new Animal();
// This will error
Dog anotherPoodle = (Dog) poodle;
// Exception java.lang.ClassCastException: class REPL.$JShell$11$Animal cannot be cast to class REPL.$JShell$12$Dog (REPL.$JShell$11$Animal and REPL.$JShell$12$Dog are in unnamed module of loader jdk.jshell.execution.DefaultLoaderDelegate$RemoteClassLoader @3cd1a2f1)
```

```
jshell> Dog husky = new Dog();
husky ==> Dog@484b61fc

jshell> Animal anotherHusky = husky;
anotherHusky ==> Dog@484b61fc

jshell> Animal anotherHusky = (Animal) husky;
anotherHusky ==> Dog@484b61fc
```

# Type/Sub-type Consistency

Type/subtype consistency is an important concept in object-oriented programming (OOP) that deals with how subtypes relate to their supertypes. It refers to the ability of a subtype to be used in the same way as its supertype, without breaking the program's correctness.

In OOP, a subclass or subtype is a class that inherits from a superclass or supertype. The subclass inherits all the properties and behaviors of the superclass and can also define its own properties and behaviors. Type/subtype consistency requires that the properties and behaviors of the subclass should not contradict or violate the properties and behaviors of the superclass.

For example, consider a class hierarchy where we have a superclass Animal and a subclass Dog. The Dog class inherits properties and behaviors from the Animal class, such as eat() and sleep(). We can use a Dog object in the same way we use an Animal object, since a Dog is an Animal. This is because Dog is a subtype of Animal and has the same properties and behaviors as its supertype, plus its own unique properties and behaviors.

Type/subtype consistency is important because it allows code to be written in a modular and reusable way. If a subclass is consistent with its supertype, then any code that works with the supertype should work with the subclass as well. This allows for greater flexibility and scalability in software design.

In summary, type/subtype consistency is the property of a subtype to be used in the same way as its supertype, without breaking the program's correctness. It is an important concept in OOP that allows for modular and reusable code.

```java
public class Animal {
    public void makeSound() {
        System.out.println("Animal is making a sound.");
    }
}

public class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Dog is barking.");
    }
}

public class Cat extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Cat is meowing.");
    }
}

public class AnimalSoundMaker {
    public void makeAnimalSound(Animal animal) {
        animal.makeSound();
    }
}

public class Main {
    public static void main(String[] args) {
        AnimalSoundMaker soundMaker = new AnimalSoundMaker();
        Animal dog = new Dog();
        Animal cat = new Cat();
        soundMaker.makeAnimalSound(dog); // Outputs "Dog is barking."
        soundMaker.makeAnimalSound(cat); // Outputs "Cat is meowing."
    }
}
```

## Polymorphism

Polymorphism is a concept in object-oriented programming that allows objects of different classes to be treated as if they were objects of the same class. In other words, it allows objects to take on multiple forms. There are two main types of polymorphism: static (or compile-time) polymorphism and dynamic (or run-time) polymorphism.

### Static polymorphism

Static polymorphism is achieved through method overloading, where multiple methods can have the same name but different parameters, allowing the appropriate method to be called based on the types of arguments passed.

### Dynamic polymorphism

Dynamic polymorphism is achieved through method overriding, where a subclass provides its own implementation of a method that is already defined in its superclass. This allows the subclass to use the method of the superclass as is or override it with its own implementation.

```java
public class Animal {
    public void makeSound() {
        System.out.println("The animal makes a sound");
    }
}

public class Dog extends Animal {
    public void makeSound() {
        System.out.println("The dog barks");
    }
}

public class Cat extends Animal {
    public void makeSound() {
        System.out.println("The cat meows");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal animal1 = new Dog();
        Animal animal2 = new Cat();
        
        animal1.makeSound(); // Output: The dog barks
        animal2.makeSound(); // Output: The cat meows
    }
}
```

In this example, Animal is the superclass, and Dog and Cat are subclasses. Each subclass overrides the makeSound() method of the Animal class with its own implementation. In the Main class, animal1 is an instance of the Dog class and animal2 is an instance of the Cat class. Even though they are of different classes, they can both be treated as Animal objects and the makeSound() method will output the appropriate sound for each object. This is an example of polymorphism in action.



