"use strict";(self.webpackChunkprogramming_basics=self.webpackChunkprogramming_basics||[]).push([[351],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>h});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(t),m=i,h=d["".concat(l,".").concat(m)]||d[m]||u[m]||r;return t?a.createElement(h,o(o({ref:n},p),{},{components:t})):a.createElement(h,o({ref:n},p))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,o=new Array(r);o[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[d]="string"==typeof e?e:i,o[1]=s;for(var c=2;c<r;c++)o[c]=t[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},5162:(e,n,t)=>{t.d(n,{Z:()=>o});var a=t(7294),i=t(6010);const r={tabItem:"tabItem_Ymn6"};function o(e){let{children:n,hidden:t,className:o}=e;return a.createElement("div",{role:"tabpanel",className:(0,i.Z)(r.tabItem,o),hidden:t},n)}},4866:(e,n,t)=>{t.d(n,{Z:()=>N});var a=t(7462),i=t(7294),r=t(6010),o=t(2466),s=t(6550),l=t(1980),c=t(7392),p=t(12);function d(e){return function(e){return i.Children.map(e,(e=>{if((0,i.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:n,label:t,attributes:a,default:i}}=e;return{value:n,label:t,attributes:a,default:i}}))}function u(e){const{values:n,children:t}=e;return(0,i.useMemo)((()=>{const e=n??d(t);return function(e){const n=(0,c.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function m(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function h(e){let{queryString:n=!1,groupId:t}=e;const a=(0,s.k6)(),r=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,l._X)(r),(0,i.useCallback)((e=>{if(!r)return;const n=new URLSearchParams(a.location.search);n.set(r,e),a.replace({...a.location,search:n.toString()})}),[r,a])]}function f(e){const{defaultValue:n,queryString:t=!1,groupId:a}=e,r=u(e),[o,s]=(0,i.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!m({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const a=t.find((e=>e.default))??t[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:n,tabValues:r}))),[l,c]=h({queryString:t,groupId:a}),[d,f]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[a,r]=(0,p.Nk)(t);return[a,(0,i.useCallback)((e=>{t&&r.set(e)}),[t,r])]}({groupId:a}),b=(()=>{const e=l??d;return m({value:e,tabValues:r})?e:null})();(0,i.useLayoutEffect)((()=>{b&&s(b)}),[b]);return{selectedValue:o,selectValue:(0,i.useCallback)((e=>{if(!m({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);s(e),c(e),f(e)}),[c,f,r]),tabValues:r}}var b=t(2389);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function v(e){let{className:n,block:t,selectedValue:s,selectValue:l,tabValues:c}=e;const p=[],{blockElementScrollPositionUntilNextRender:d}=(0,o.o5)(),u=e=>{const n=e.currentTarget,t=p.indexOf(n),a=c[t].value;a!==s&&(d(n),l(a))},m=e=>{let n=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{const t=p.indexOf(e.currentTarget)+1;n=p[t]??p[0];break}case"ArrowLeft":{const t=p.indexOf(e.currentTarget)-1;n=p[t]??p[p.length-1];break}}n?.focus()};return i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":t},n)},c.map((e=>{let{value:n,label:t,attributes:o}=e;return i.createElement("li",(0,a.Z)({role:"tab",tabIndex:s===n?0:-1,"aria-selected":s===n,key:n,ref:e=>p.push(e),onKeyDown:m,onClick:u},o,{className:(0,r.Z)("tabs__item",g.tabItem,o?.className,{"tabs__item--active":s===n})}),t??n)})))}function y(e){let{lazy:n,children:t,selectedValue:a}=e;if(t=Array.isArray(t)?t:[t],n){const e=t.find((e=>e.props.value===a));return e?(0,i.cloneElement)(e,{className:"margin-top--md"}):null}return i.createElement("div",{className:"margin-top--md"},t.map(((e,n)=>(0,i.cloneElement)(e,{key:n,hidden:e.props.value!==a}))))}function k(e){const n=f(e);return i.createElement("div",{className:(0,r.Z)("tabs-container",g.tabList)},i.createElement(v,(0,a.Z)({},e,n)),i.createElement(y,(0,a.Z)({},e,n)))}function N(e){const n=(0,b.Z)();return i.createElement(k,(0,a.Z)({key:String(n)},e))}},3716:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>d});var a=t(7462),i=(t(7294),t(3905)),r=t(4866),o=t(5162);const s={sidebar_position:5},l="SOLID Principles",c={unversionedId:"solid",id:"solid",title:"SOLID Principles",description:"The SOLID principles are a set of guidelines for writing software that is easy",source:"@site/docs/solid.mdx",sourceDirName:".",slug:"/solid",permalink:"/programming-basics/docs/solid",draft:!1,editUrl:"https://github.com/alexkmj/programming-basics/tree/master/docs/docs/solid.mdx",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Inheritance",permalink:"/programming-basics/docs/inheritance"},next:{title:"Generics",permalink:"/programming-basics/docs/generics"}},p={},d=[{value:"Single Responsibility Principle",id:"single-responsibility-principle",level:2},{value:"Open-Closed Principle",id:"open-closed-principle",level:2},{value:"Liskov Substitution Principle",id:"liskov-substitution-principle",level:2},{value:"Interface Segregation Principle (ISP)",id:"interface-segregation-principle-isp",level:2},{value:"Dependency Inversion Principle",id:"dependency-inversion-principle",level:2}],u={toc:d},m="wrapper";function h(e){let{components:n,...t}=e;return(0,i.kt)(m,(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"solid-principles"},"SOLID Principles"),(0,i.kt)("p",null,'The SOLID principles are a set of guidelines for writing software that is easy\nto understand, maintain, and extend. They were first introduced by Robert C.\nMartin, and are widely used in object-oriented programming. The acronym "SOLID"\nstands for:'),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Single Responsibility Principle"),(0,i.kt)("li",{parentName:"ul"},"Open-Closed Principle"),(0,i.kt)("li",{parentName:"ul"},"Liskov Substitution Principle"),(0,i.kt)("li",{parentName:"ul"},"Interface Segregation Principle"),(0,i.kt)("li",{parentName:"ul"},"Dependency Inversion Principle")),(0,i.kt)("h2",{id:"single-responsibility-principle"},"Single Responsibility Principle"),(0,i.kt)("p",null,"The Single Responsibility Principle states that a class should have only one\nreason to change. In other words, a class should have only one responsibility.\nThis makes the class easier to understand, test, and maintain."),(0,i.kt)("p",null,"Suppose we have a class called ",(0,i.kt)("inlineCode",{parentName:"p"},"Order")," that represents an order in an online\nstore. The class has a ",(0,i.kt)("inlineCode",{parentName:"p"},"calculateTotalPrice()")," method, which calculates the\ntotal price of the order. However, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Order")," class also has a ",(0,i.kt)("inlineCode",{parentName:"p"},"save()")," method,\nwhich saves the order to a database."),(0,i.kt)(r.Z,{mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public class Order {\n    private List<Item> items;\n    // constructor, getters and setters\n    \n    public double calculateTotalPrice() {\n        // calculate total price of the order\n    }\n\n    public void save() {\n        // save the order to the database\n    }\n}\n"))),(0,i.kt)(o.Z,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <iostream>\n#include <vector>\n\nclass Item {\n    // Item class definition\n};\n\nclass Order {\nprivate:\n    std::vector<Item> items;\n\npublic:\n    Order(std::vector<Item> items) {\n        this->items = items;\n    }\n\n    double calculateTotalPrice() {\n        // calculate total price of the order\n    }\n\n    void save() {\n        // save the order to the database\n    }\n};\n\nint main() {\n    std::vector<Item> items;\n    // Add items to the vector\n    Order order(items);\n    order.calculateTotalPrice();\n    order.save();\n    return 0;\n}\n"))),(0,i.kt)(o.Z,{value:"python",label:"Python",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class Order:\n    def __init__(self, items):\n        self.items = items\n\n    def calculateTotalPrice(self):\n        # calculate total price of the order\n        pass\n\n    def save(self):\n        # save the order to the database\n        pass\n")))),(0,i.kt)("p",null,"This violates the SRP, as the ",(0,i.kt)("inlineCode",{parentName:"p"},"Order")," class\nnow has two responsibilities: calculating the total price and saving the order.\nTo fix this, we can create a separate class called ",(0,i.kt)("inlineCode",{parentName:"p"},"OrderRepository"),", which is\nresponsible for saving orders to the database. The ",(0,i.kt)("inlineCode",{parentName:"p"},"Order")," class can then\ndelegate the responsibility of saving the order to the ",(0,i.kt)("inlineCode",{parentName:"p"},"OrderRepository")," class."),(0,i.kt)(r.Z,{mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public class Order {\n    private List<Item> items;\n    // constructor, getters and setters\n    \n    public double calculateTotalPrice() {\n        // calculate total price of the order\n    }\n}\n\npublic class OrderRepository {\n    public void save(Order order) {\n        // save the order to the database\n    }\n}\n"))),(0,i.kt)(o.Z,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <iostream>\n#include <vector>\n\nclass Item {};\n\nclass Order {\n    private:\n        std::vector<Item> items;\n    \n    public:\n        Order(std::vector<Item> items) : items(items) {}\n        \n        double calculateTotalPrice() {\n            // calculate total price of the order\n            return 0.0;\n        }\n};\n\nclass OrderRepository {\n    public:\n        void save(Order order) {\n            // save the order to the database\n        }\n};\n"))),(0,i.kt)(o.Z,{value:"python",label:"Python",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class Order:\n    def __init__(self, items):\n        self.items = items\n\n    def calculateTotalPrice(self):\n        # calculate total price of the order\n        pass\n\nclass OrderRepository:\n    def save(self, order):\n        # save the order to the database\n        pass\n")))),(0,i.kt)("h2",{id:"open-closed-principle"},"Open-Closed Principle"),(0,i.kt)("p",null,"The Open-Closed Principle states that a class should be open for extension but\nclosed for modification. In other words, we should be able to add new\nfunctionality to a class without modifying its existing code."),(0,i.kt)("admonition",{title:"wrong implementation",type:"danger"},(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'public class Shape {\n    public string type;\n\n    public class Shape(String type) {\n        this.type = type;\n    }\n\n    public void draw() {\n        if (this.type == "Rectangle") {\n            // draw a rectangle\n        } else if (this.type == "Circle") {\n            // draw a circle\n        }\n    }\n}\n\npublic class Circle extends Shape {\n    public class Circle() {\n        this.super("Circle");\n    }\n}\n')),(0,i.kt)("p",{parentName:"admonition"},"In the above example, we cannot extend ",(0,i.kt)("inlineCode",{parentName:"p"},"Shape")," without modifying ",(0,i.kt)("inlineCode",{parentName:"p"},"Shape"),". This\nviolates the open-close principle.")),(0,i.kt)("p",null,"Suppose we have a class called ",(0,i.kt)("inlineCode",{parentName:"p"},"Shape")," that represents a geometric shape. The\n",(0,i.kt)("inlineCode",{parentName:"p"},"Shape")," class has a ",(0,i.kt)("inlineCode",{parentName:"p"},"draw()")," method, which draws the shape. Now, suppose we want\nto add a new type of shape called ",(0,i.kt)("inlineCode",{parentName:"p"},"Triangle"),". We can create a new class called\n",(0,i.kt)("inlineCode",{parentName:"p"},"Triangle")," that extends the ",(0,i.kt)("inlineCode",{parentName:"p"},"Shape")," class and overrides the ",(0,i.kt)("inlineCode",{parentName:"p"},"draw()")," method."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public abstract class Shape {\n    public abstract void draw();\n}\n\npublic class Circle extends Shape {\n    public void draw() {\n        // draw a circle\n    }\n}\n\npublic class Square extends Shape {\n    public void draw() {\n        // draw a square\n    }\n}\n\npublic class Triangle extends Shape {\n    public void draw() {\n        // draw a triangle\n    }\n}\n\n")),(0,i.kt)("h2",{id:"liskov-substitution-principle"},"Liskov Substitution Principle"),(0,i.kt)("p",null,"The Liskov Substitution Principle states that objects of a superclass should be\nable to be replaced with objects of a subclass without affecting the correctness\nof the program."),(0,i.kt)("p",null,"Suppose we have a class called ",(0,i.kt)("inlineCode",{parentName:"p"},"Bird")," that represents a bird. The ",(0,i.kt)("inlineCode",{parentName:"p"},"Bird")," class\nhas a ",(0,i.kt)("inlineCode",{parentName:"p"},"fly()")," method, which allows the bird to fly. Now, suppose we have a\nsubclass of ",(0,i.kt)("inlineCode",{parentName:"p"},"Bird")," called ",(0,i.kt)("inlineCode",{parentName:"p"},"Penguin"),". Penguins cannot fly, so the ",(0,i.kt)("inlineCode",{parentName:"p"},"fly()")," method\nshould be disabled for ",(0,i.kt)("inlineCode",{parentName:"p"},"Penguin")," objects."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'public class Bird {\n    public void fly() {\n        // fly\n    }\n}\n\npublic class Penguin extends Bird {\n    public void fly() {\n        throw new UnsupportedOperationException("Penguins cannot fly");\n    }\n}\n')),(0,i.kt)("h2",{id:"interface-segregation-principle-isp"},"Interface Segregation Principle (ISP)"),(0,i.kt)("p",null,"The Interface Segregation Principle (ISP) states that a client should not be\nforced to depend on methods it does not use. In other words, interfaces should\nbe designed in such a way that they are specific to the needs of the client, and\nnot overly broad or general. Clients should only be required to implement the\nmethods that they need, and not be forced to implement unnecessary methods."),(0,i.kt)("p",null,"The goal of ISP is to make software more modular, flexible, and maintainable. By\ncreating smaller and more focused interfaces, it is easier to change and update\nthe software without affecting other parts of the system."),(0,i.kt)("p",null,"For example, consider an interface for a document processing system that\nincludes methods for editing, formatting, and printing documents. If a client\nonly needs to edit documents, they should not be required to implement the\nformatting and printing methods. Instead, the interface should be split into\nsmaller, more focused interfaces, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"EditableDocument")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"PrintableDocument"),", which can be implemented separately by different clients\ndepending on their needs."),(0,i.kt)("p",null,"Overall, ISP encourages software developers to design interfaces that are\nfocused, flexible, and easy to maintain, leading to better software design and\nfewer unintended side effects when making changes to the system."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'// This interface represents a general document that can be printed\ninterface Document {\n    void print();\n}\n\n// This interface represents a document that can be scanned\ninterface Scannable {\n    void scan();\n}\n\n// This interface represents a document that can be copied\ninterface Copyable {\n    void copy();\n}\n\n// This class represents a simple document that can be printed\nclass SimpleDocument implements Document {\n    public void print() {\n        System.out.println("Printing simple document");\n    }\n}\n\n// This class represents a complex document that can be printed and scanned\nclass ComplexDocument implements Document, Scannable {\n    public void print() {\n        System.out.println("Printing complex document");\n    }\n\n    public void scan() {\n        System.out.println("Scanning complex document");\n    }\n}\n\n// This class represents a photocopier that can print, scan and copy documents\nclass Photocopier implements Document, Scannable, Copyable {\n    public void print() {\n        System.out.println("Printing document");\n    }\n\n    public void scan() {\n        System.out.println("Scanning document");\n    }\n\n    public void copy() {\n        System.out.println("Copying document");\n    }\n}\n')),(0,i.kt)("p",null,"In this example, we have three interfaces (",(0,i.kt)("inlineCode",{parentName:"p"},"Document"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Scannable"),", and\n",(0,i.kt)("inlineCode",{parentName:"p"},"Copyable"),") that define different capabilities of documents. The\n",(0,i.kt)("inlineCode",{parentName:"p"},"SimpleDocument")," class implements the ",(0,i.kt)("inlineCode",{parentName:"p"},"Document")," interface, which means it can\nbe printed. The ",(0,i.kt)("inlineCode",{parentName:"p"},"ComplexDocument")," class implements both the ",(0,i.kt)("inlineCode",{parentName:"p"},"Document")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"Scannable")," interfaces, which means it can be printed and scanned. Finally, the\n",(0,i.kt)("inlineCode",{parentName:"p"},"Photocopier")," class implements all three interfaces, which means it can print,\nscan and copy documents."),(0,i.kt)("p",null,"This design follows the Interface Segregation Principle because each interface\ndefines a single responsibility, and clients (such as the ",(0,i.kt)("inlineCode",{parentName:"p"},"Photocopier")," class)\ncan choose which interfaces to implement based on their needs. This makes the\ncode more modular and flexible, and avoids forcing clients to implement\nunnecessary methods."),(0,i.kt)("h2",{id:"dependency-inversion-principle"},"Dependency Inversion Principle"),(0,i.kt)("p",null,"The Dependency Inversion Principle (DIP) states that high-level modules should\nnot depend on low-level modules, but both should depend on abstractions.\n",(0,i.kt)("inlineCode",{parentName:"p"},"Abstractions")," should not depend on details, but details should depend on\nabstractions."),(0,i.kt)("p",null,"This principle suggests that instead of depending on specific implementations,\ncode should depend on abstractions or interfaces. This allows for greater\nflexibility and easier maintenance, as the underlying implementation can be\nchanged without affecting the code that depends on it."),(0,i.kt)("p",null,"For example, consider a system that sends notifications to users through email,\nSMS, or push notifications. Instead of implementing the notification sending\nlogic directly in a high-level module, the code should depend on an abstraction\nor interface that defines the notification sending behavior. This allows for\neasy addition or removal of notification methods without affecting the rest of\nthe codebase."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'// Notification interface\npublic interface Notification {\n    public void sendNotification(String message);\n}\n\n// Email notification implementation\npublic class EmailNotification implements Notification {\n    @Override\n    public void sendNotification(String message) {\n        // Send email notification\n    }\n}\n\n// SMS notification implementation\npublic class SmsNotification implements Notification {\n    @Override\n    public void sendNotification(String message) {\n        // Send SMS notification\n    }\n}\n\n// Notification sender\npublic class NotificationSender {\n    private Notification notification;\n\n    // Constructor injection\n    public NotificationSender(Notification notification) {\n        this.notification = notification;\n    }\n\n    public void send(String message) {\n        notification.sendNotification(message);\n    }\n}\n\n// Usage example\npublic static void main(String[] args) {\n    NotificationSender sender = new NotificationSender(new EmailNotification());\n    sender.send("New message!");\n\n    sender = new NotificationSender(new SmsNotification());\n    sender.send("New message!");\n}\n')),(0,i.kt)("p",null,"In this example, the ",(0,i.kt)("inlineCode",{parentName:"p"},"NotificationSender")," class depends on the ",(0,i.kt)("inlineCode",{parentName:"p"},"Notification"),"\ninterface, rather than a specific implementation. This allows for easy swapping\nof the underlying implementation without affecting the ",(0,i.kt)("inlineCode",{parentName:"p"},"NotificationSender"),"\ncode. The ",(0,i.kt)("inlineCode",{parentName:"p"},"Notification")," interface defines a ",(0,i.kt)("inlineCode",{parentName:"p"},"sendNotification()")," method, which\nis implemented by the ",(0,i.kt)("inlineCode",{parentName:"p"},"EmailNotification")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"SmsNotification")," classes. The\n",(0,i.kt)("inlineCode",{parentName:"p"},"NotificationSender")," class is constructed with a specific implementation of the\n",(0,i.kt)("inlineCode",{parentName:"p"},"Notification")," interface using constructor injection."))}h.isMDXComponent=!0}}]);