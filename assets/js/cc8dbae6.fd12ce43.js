"use strict";(self.webpackChunkprogramming_basics=self.webpackChunkprogramming_basics||[]).push([[149],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>h});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),u=c(a),m=r,h=u["".concat(l,".").concat(m)]||u[m]||d[m]||i;return a?n.createElement(h,s(s({ref:t},p),{},{components:a})):n.createElement(h,s({ref:t},p))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,s=new Array(i);s[0]=m;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[u]="string"==typeof e?e:r,s[1]=o;for(var c=2;c<i;c++)s[c]=a[c];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},5162:(e,t,a)=>{a.d(t,{Z:()=>s});var n=a(7294),r=a(6010);const i={tabItem:"tabItem_Ymn6"};function s(e){let{children:t,hidden:a,className:s}=e;return n.createElement("div",{role:"tabpanel",className:(0,r.Z)(i.tabItem,s),hidden:a},t)}},4866:(e,t,a)=>{a.d(t,{Z:()=>v});var n=a(7462),r=a(7294),i=a(6010),s=a(2466),o=a(6550),l=a(1980),c=a(7392),p=a(12);function u(e){return function(e){return r.Children.map(e,(e=>{if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:t,label:a,attributes:n,default:r}}=e;return{value:t,label:a,attributes:n,default:r}}))}function d(e){const{values:t,children:a}=e;return(0,r.useMemo)((()=>{const e=t??u(a);return function(e){const t=(0,c.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,a])}function m(e){let{value:t,tabValues:a}=e;return a.some((e=>e.value===t))}function h(e){let{queryString:t=!1,groupId:a}=e;const n=(0,o.k6)(),i=function(e){let{queryString:t=!1,groupId:a}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return a??null}({queryString:t,groupId:a});return[(0,l._X)(i),(0,r.useCallback)((e=>{if(!i)return;const t=new URLSearchParams(n.location.search);t.set(i,e),n.replace({...n.location,search:t.toString()})}),[i,n])]}function g(e){const{defaultValue:t,queryString:a=!1,groupId:n}=e,i=d(e),[s,o]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:a}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${a.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const n=a.find((e=>e.default))??a[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:i}))),[l,c]=h({queryString:a,groupId:n}),[u,g]=function(e){let{groupId:t}=e;const a=function(e){return e?`docusaurus.tab.${e}`:null}(t),[n,i]=(0,p.Nk)(a);return[n,(0,r.useCallback)((e=>{a&&i.set(e)}),[a,i])]}({groupId:n}),f=(()=>{const e=l??u;return m({value:e,tabValues:i})?e:null})();(0,r.useLayoutEffect)((()=>{f&&o(f)}),[f]);return{selectedValue:s,selectValue:(0,r.useCallback)((e=>{if(!m({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);o(e),c(e),g(e)}),[c,g,i]),tabValues:i}}var f=a(2389);const y={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function b(e){let{className:t,block:a,selectedValue:o,selectValue:l,tabValues:c}=e;const p=[],{blockElementScrollPositionUntilNextRender:u}=(0,s.o5)(),d=e=>{const t=e.currentTarget,a=p.indexOf(t),n=c[a].value;n!==o&&(u(t),l(n))},m=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const a=p.indexOf(e.currentTarget)+1;t=p[a]??p[0];break}case"ArrowLeft":{const a=p.indexOf(e.currentTarget)-1;t=p[a]??p[p.length-1];break}}t?.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":a},t)},c.map((e=>{let{value:t,label:a,attributes:s}=e;return r.createElement("li",(0,n.Z)({role:"tab",tabIndex:o===t?0:-1,"aria-selected":o===t,key:t,ref:e=>p.push(e),onKeyDown:m,onClick:d},s,{className:(0,i.Z)("tabs__item",y.tabItem,s?.className,{"tabs__item--active":o===t})}),a??t)})))}function w(e){let{lazy:t,children:a,selectedValue:n}=e;if(a=Array.isArray(a)?a:[a],t){const e=a.find((e=>e.props.value===n));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},a.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==n}))))}function k(e){const t=g(e);return r.createElement("div",{className:(0,i.Z)("tabs-container",y.tabList)},r.createElement(b,(0,n.Z)({},e,t)),r.createElement(w,(0,n.Z)({},e,t)))}function v(e){const t=(0,f.Z)();return r.createElement(k,(0,n.Z)({key:String(t)},e))}},2073:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var n=a(7462),r=(a(7294),a(3905));a(4866),a(5162);const i={sidebar_position:6},s="Generics",o={unversionedId:"generics",id:"generics",title:"Generics",description:"Generics is a feature in Object-Oriented Programming (OOP) that allows for the",source:"@site/docs/generics.mdx",sourceDirName:".",slug:"/generics",permalink:"/programming-basics/docs/generics",draft:!1,editUrl:"https://github.com/alexkmj/programming-basics/tree/master/docs/docs/generics.mdx",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"SOLID Principles",permalink:"/programming-basics/docs/solid"},next:{title:"Substitution",permalink:"/programming-basics/docs/substitution"}},l={},c=[{value:"Wildcards",id:"wildcards",level:2},{value:"Generics in Static Methods",id:"generics-in-static-methods",level:2},{value:"The Diamond Operator",id:"the-diamond-operator",level:2},{value:"Wrapper Classes",id:"wrapper-classes",level:2},{value:"Generic subtypes",id:"generic-subtypes",level:2},{value:"Generic Type and Parameterised Type",id:"generic-type-and-parameterised-type",level:2},{value:"Bounded Wildcards",id:"bounded-wildcards",level:2}],p={toc:c},u="wrapper";function d(e){let{components:t,...a}=e;return(0,r.kt)(u,(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"generics"},"Generics"),(0,r.kt)("p",null,"Generics is a feature in Object-Oriented Programming (OOP) that allows for the\ncreation of classes, interfaces, and methods that can work with any type of\nobject. It provides a way to write reusable code and improve type safety by\nallowing classes and methods to be parameterized with types."),(0,r.kt)("p",null,"Generics provide a way to create type-safe code, which means that the code is\ndesigned to catch errors at compile-time rather than at runtime. With generics,\nyou can write code that works with any type of object without sacrificing type\nsafety."),(0,r.kt)("p",null,"The most common use of generics is to create collections, such as ",(0,r.kt)("inlineCode",{parentName:"p"},"ArrayList"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},"HashSet"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"LinkedList"),", that can hold any type of object. By using\ngenerics, you can write a single implementation of a collection that can be used\nto store and retrieve objects of any type, rather than having to write a\nseparate implementation for each type of object."),(0,r.kt)("p",null,"Generics are supported by many programming languages, including Java, C#, and\nPython. They are an important tool for developers who want to write reusable,\ntype-safe code that can work with any type of object."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.ArrayList;\n\npublic class Example {\n  public static void main(String[] args) {\n    ArrayList<String> list = new ArrayList<String>();\n    list.add("Hello");\n    list.add("World");\n    list.add("!");\n\n    for (String str : list) {\n      System.out.println(str);\n    }\n  }\n}\n')),(0,r.kt)("p",null,"In this example, we're creating an ",(0,r.kt)("inlineCode",{parentName:"p"},"ArrayList")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"String")," objects. The\n",(0,r.kt)("inlineCode",{parentName:"p"},"ArrayList")," class is a generic class, and we're specifying that we want to store\n",(0,r.kt)("inlineCode",{parentName:"p"},"String")," objects by putting ",(0,r.kt)("inlineCode",{parentName:"p"},"<String>")," after the class name. We then add three\n",(0,r.kt)("inlineCode",{parentName:"p"},"String")," objects to the list, and use a for loop to iterate over the list and\nprint out each ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),". Because we've specified that the list can only contain\n",(0,r.kt)("inlineCode",{parentName:"p"},"String")," objects, we can be sure that the for loop will only encounter ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),"\nobjects and won't throw any type errors."),(0,r.kt)("h2",{id:"wildcards"},"Wildcards"),(0,r.kt)("p",null,'In Java Generics, a wildcard refers to the use of the question mark symbol "?" as a type argument when defining a generic class, method or interface. It allows you to create a more flexible and generalizable code that can accept different types of parameters at runtime.'),(0,r.kt)("p",null,"Wildcards can be used in three different ways:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Unbounded Wildcards",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-java"},"List<?> list = new ArrayList<>();\n"))),(0,r.kt)("li",{parentName:"ul"},"Upper-bounded Wildcards",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-java"},"List<? extends Number> list = new ArrayList<Integer>();\n"))),(0,r.kt)("li",{parentName:"ul"},"Lower-bounded Wildcards",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-java"},"List<? super Integer> list = new ArrayList<Number>();\n")))),(0,r.kt)("p",null,"Wildcards are useful when you want to write code that can work with different types of objects without knowing their exact types at compile time. They can help you to create more flexible and reusable code. However, they should be used with care because they can make your code more complex and harder to understand."),(0,r.kt)("h2",{id:"generics-in-static-methods"},"Generics in Static Methods"),(0,r.kt)("p",null,"Generics can also be used in static methods in Java. When a static method is generic, the type parameter must be declared before the return type of the method. This allows the method to use the type parameter in its arguments or return type."),(0,r.kt)("p",null,"Here's an example of a generic static method that takes an array of any type and returns the maximum element:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public static <T extends Comparable<T>> T findMax(T[] arr) {\n    T max = arr[0];\n    for (int i = 1; i < arr.length; i++) {\n        if (arr[i].compareTo(max) > 0) {\n            max = arr[i];\n        }\n    }\n    return max;\n}\n")),(0,r.kt)("p",null,"In this example, the type parameter ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," is bounded by ",(0,r.kt)("inlineCode",{parentName:"p"},"Comparable<T>"),", which means that T must be a type that implements the Comparable interface. The method then initializes max to the first element of the array and iterates through the rest of the array to find the maximum element. Finally, it returns the maximum element."),(0,r.kt)("p",null,"The method can be called with any array of Comparable elements, like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'Integer[] intArr = {1, 2, 3};\nInteger maxInt = findMax(intArr);\nSystem.out.println("Max integer: " + maxInt);\n\nString[] strArr = {"apple", "banana", "cherry"};\nString maxStr = findMax(strArr);\nSystem.out.println("Max string: " + maxStr);\n')),(0,r.kt)("p",null,"In this example, the findMax method is called with an array of Integer elements and an array of String elements, and it returns the maximum element of each array."),(0,r.kt)("h2",{id:"the-diamond-operator"},"The Diamond Operator"),(0,r.kt)("p",null,"The diamond operator ",(0,r.kt)("inlineCode",{parentName:"p"},"<>")," is a feature in Java introduced in Java 7. It provides a simplified syntax for creating an instance of a parameterized class by allowing the compiler to infer the type arguments from the context."),(0,r.kt)("p",null,"Prior to the diamond operator, when creating an instance of a parameterized class, it was necessary to specify the type arguments twice - once when declaring the variable and again when creating the instance, like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"List<String> myList = new ArrayList<String>();\n")),(0,r.kt)("p",null,"With the diamond operator, the second declaration of type arguments can be replaced with an empty set of angle brackets, like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"List<String> myList = new ArrayList<>();\n")),(0,r.kt)("p",null,"The diamond operator can be used with any type of parameterized class, including nested parameterized classes and anonymous inner classes."),(0,r.kt)("p",null,"One important thing to note is that the diamond operator can only be used when the type arguments can be inferred from the context, so it cannot be used with constructors that do not have any arguments or with constructors that have arguments of different types. In those cases, the type arguments must still be explicitly specified."),(0,r.kt)("h2",{id:"wrapper-classes"},"Wrapper Classes"),(0,r.kt)("p",null,"In Java, primitive types (such as int, float, double, etc.) are not objects and do not belong to a class hierarchy. However, sometimes it is necessary to treat these primitives as objects, for example, when they need to be passed as an argument to a method that requires an object, or when they need to be stored in a collection."),(0,r.kt)("p",null,"To solve this problem, Java provides a set of wrapper classes, which are classes that wrap the primitive types and provide a way to treat them as objects. The wrapper classes are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Boolean for the boolean primitive type"),(0,r.kt)("li",{parentName:"ul"},"Byte for the byte primitive type"),(0,r.kt)("li",{parentName:"ul"},"Short for the short primitive type"),(0,r.kt)("li",{parentName:"ul"},"Integer for the int primitive type"),(0,r.kt)("li",{parentName:"ul"},"Long for the long primitive type"),(0,r.kt)("li",{parentName:"ul"},"Float for the float primitive type"),(0,r.kt)("li",{parentName:"ul"},"Double for the double primitive type"),(0,r.kt)("li",{parentName:"ul"},"Character for the char primitive type"),(0,r.kt)("li",{parentName:"ul"},"Wrapper classes provide a set of methods that allow you to convert between the primitive type and the wrapper object. For example, you can use the intValue() method of the Integer class to get the int value of an Integer object.")),(0,r.kt)("p",null,"Wrapper classes are also useful when you need to store primitive types in collections, as collections can only store objects. For example, you can use an ",(0,r.kt)("inlineCode",{parentName:"p"},"ArrayList<Integer>")," to store a list of integers."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'int myInt = 42;\nInteger myInteger = Integer.valueOf(myInt); // create an Integer object from the int value\nint myInt2 = myInteger.intValue(); // get the int value from the Integer object\nSystem.out.println("myInt2 = " + myInt2); // prints "myInt2 = 42"\n')),(0,r.kt)("h2",{id:"generic-subtypes"},"Generic subtypes"),(0,r.kt)("p",null,"In Java, generic subtypes are a way to provide a more specific type argument to a generic class or method. This is achieved by defining a new generic class or method that extends or implements an existing one, but with a more specific type argument."),(0,r.kt)("p",null,"For example, suppose we have a generic class ",(0,r.kt)("inlineCode",{parentName:"p"},"Box<T>")," that can hold any type of object, and we want to create a new class StringBox that can only hold strings. We can define StringBox as a subtype of ",(0,r.kt)("inlineCode",{parentName:"p"},"Box<String>"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public class Box<T> {\n    private T item;\n\n    public void set(T item) {\n        this.item = item;\n    }\n\n    public T get() {\n        return item;\n    }\n}\n\npublic class StringBox extends Box<String> {\n    // This class inherits all the methods of Box<String>,\n    // but can only hold String objects\n}\n")),(0,r.kt)("p",null,"Now we can create a StringBox object and use it to hold a string:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'StringBox box = new StringBox();\nbox.set("hello");\nString s = box.get();  // This is guaranteed to be a String\n')),(0,r.kt)("p",null,"Similarly, we can define a new generic method that is a subtype of an existing one, but with a more specific type argument. For example, suppose we have a generic method ",(0,r.kt)("inlineCode",{parentName:"p"},"printList(List<T> list)")," that can print any list of objects, and we want to create a new method ",(0,r.kt)("inlineCode",{parentName:"p"},"printStringList(List<String> list)")," that can only print lists of strings. We can define printStringList as a subtype of printList:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public static <T> void printList(List<T> list) {\n    for (T item : list) {\n        System.out.println(item);\n    }\n}\n\npublic static void printStringList(List<String> list) {\n    // This method is a subtype of printList(List<T>),\n    // but with T fixed to String\n    printList(list);\n}\n")),(0,r.kt)("p",null,"Now we can use printStringList to print a list of strings:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'List<String> strings = Arrays.asList("hello", "world");\nprintStringList(strings);\n')),(0,r.kt)("h2",{id:"generic-type-and-parameterised-type"},"Generic Type and Parameterised Type"),(0,r.kt)("p",null,"In Java, a generic type is a generic class or interface that has one or more type parameters. A type parameter is a placeholder for a type that will be specified when an instance of the generic type is created. For example, the List interface is a generic type with a single type parameter that specifies the type of elements it contains:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public interface List<E> {\n    void add(E element);\n    E get(int index);\n}\n")),(0,r.kt)("p",null,"Here, E is a type parameter that represents the element type of the list. When a List instance is created, the type parameter is specified:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'List<String> strings = new ArrayList<>();\nstrings.add("Hello");\nString s = strings.get(0);\n')),(0,r.kt)("p",null,"In this example, strings is an instance of ArrayList that contains String elements."),(0,r.kt)("p",null,"A parameterized type is a concrete type that is created by specifying actual type arguments for the type parameters of a generic type. For example, ",(0,r.kt)("inlineCode",{parentName:"p"},"ArrayList<String>")," is a parameterized type that is created by specifying String as the actual type argument for the E type parameter of the List interface."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"List<String> strings = new ArrayList<>();\n")),(0,r.kt)("p",null,"Here, ",(0,r.kt)("inlineCode",{parentName:"p"},"ArrayList<String>")," is a parameterized type that implements the ",(0,r.kt)("inlineCode",{parentName:"p"},"List<String>")," interface."),(0,r.kt)("h2",{id:"bounded-wildcards"},"Bounded Wildcards"),(0,r.kt)("p",null,"Bounded wildcards are a feature in Java generics that allow you to restrict the type of parameter that can be passed to a generic type. This can be useful when you want to enforce a certain relationship between the types."),(0,r.kt)("p",null,"A bounded wildcard is defined using the ? wildcard character followed by an upper or lower bound. An upper bound is specified using the extends keyword, while a lower bound is specified using the super keyword."),(0,r.kt)("p",null,"For example, consider the following class hierarchy:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"class Animal {}\nclass Mammal extends Animal {}\nclass Dog extends Mammal {}\n")),(0,r.kt)("p",null,"If you have a method that takes a list of animals and you want to restrict it to only take lists of mammals or their subtypes, you can use a bounded wildcard with an upper bound:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public void doSomething(List<? extends Mammal> mammals) {\n    // do something\n}\n")),(0,r.kt)("p",null,"In this case, ",(0,r.kt)("inlineCode",{parentName:"p"},"List<? extends Mammal>"),' means "a list of any type that is a subtype of Mammal". This allows you to pass in a ',(0,r.kt)("inlineCode",{parentName:"p"},"List<Mammal>")," or a ",(0,r.kt)("inlineCode",{parentName:"p"},"List<Dog>")," to the method, but not a ",(0,r.kt)("inlineCode",{parentName:"p"},"List<Animal>"),"."),(0,r.kt)("p",null,"If you want to restrict the type parameter to be a super type of a certain type, you can use a bounded wildcard with a lower bound:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public void doSomething(List<? super Mammal> mammals) {\n    // do something\n}\n")),(0,r.kt)("p",null,"In this case, ",(0,r.kt)("inlineCode",{parentName:"p"},"List<? super Mammal>"),' means "a list of any type that is a supertype of Mammal". This allows you to pass in a ',(0,r.kt)("inlineCode",{parentName:"p"},"List<Animal>")," or a ",(0,r.kt)("inlineCode",{parentName:"p"},"List<Object>")," to the method, but not a ",(0,r.kt)("inlineCode",{parentName:"p"},"List<Dog>")),(0,r.kt)("h1",{id:"raw-types"},"Raw types"),(0,r.kt)("p",null,"In Java, a raw type is a reference to a generic class or interface without providing the required type parameter. It can be used in situations where the type parameter is unknown or irrelevant. However, using raw types can result in potential errors and is generally not recommended."),(0,r.kt)("p",null,"For example, consider the following generic class:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public class Box<T> {\n    private T t;\n\n    public void set(T t) {\n        this.t = t;\n    }\n\n    public T get() {\n        return t;\n    }\n}\n")),(0,r.kt)("p",null,"If we create an instance of Box without providing a type parameter, it becomes a raw type:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"Box box = new Box();\n")),(0,r.kt)("p",null,"Now, any object can be added to the box, regardless of its type, and the type safety of the generic class is lost:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'box.set("Hello");\nInteger i = (Integer) box.get(); // Causes ClassCastException at runtime\n')),(0,r.kt)("p",null,"In this example, the set method is called with a string, but the get method is called with an integer, causing a ClassCastException at runtime."),(0,r.kt)("p",null,"To avoid this issue, it is recommended to always provide a type parameter when using generic classes and interfaces in Java."),(0,r.kt)("h1",{id:"type-erasure"},"Type Erasure"),(0,r.kt)("p",null,"Type erasure is a process used in Java and other programming languages with generics to implement generic types. It allows the use of generic types without sacrificing performance or type safety at runtime."),(0,r.kt)("p",null,'In Java, generics are implemented using type erasure, which means that the generic type information is removed (or "erased") at runtime. This is done to maintain backward compatibility with code written before the introduction of generics in Java.'),(0,r.kt)("p",null,"During compilation, the compiler replaces all generic type parameters with their upper bounds or Object if no bound is specified. For example, if we have a generic class ",(0,r.kt)("inlineCode",{parentName:"p"},"MyList<T>")," and instantiate it with ",(0,r.kt)("inlineCode",{parentName:"p"},"MyList<Integer>"),", the compiler replaces T with Integer and produces the code as if it was written with Integer instead of T."),(0,r.kt)("p",null,"At runtime, the compiled code behaves as if it was written without generics. This means that generic type information is not available at runtime, and all instances of the generic type are treated as if they are of the same raw type. This can lead to some unexpected behavior, such as runtime errors or incorrect type casting."),(0,r.kt)("p",null,"To summarize, type erasure is a technique used in Java to implement generics that involves replacing generic type parameters with their upper bounds or Object during compilation, and removing generic type information at runtime."),(0,r.kt)("h1",{id:"assertions"},"Assertions"),(0,r.kt)("p",null,"Assertions in programming are statements that assert or check whether certain conditions hold true or not. In other words, they are sanity checks that ensure that assumptions made in code are valid during program execution."),(0,r.kt)("p",null,"In Java, assertions are implemented using the assert keyword. An assertion takes a boolean expression and throws an AssertionError if it evaluates to false. Assertions are often used to validate inputs, outputs, or intermediate states of a program during development or testing."),(0,r.kt)("p",null,"Here is an example of how assertions can be used in Java:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'public class Example {\n    public static void main(String[] args) {\n        int num = -5;\n        assert num > 0 : "Number is not positive";\n        System.out.println("Number is positive");\n    }\n}\n')),(0,r.kt)("p",null,'In this example, an assertion is used to check if the value of the num variable is positive. If the assertion fails (i.e., num is not positive), an AssertionError will be thrown with the message "Number is not positive". Otherwise, the program will continue executing and print the message "Number is positive".'),(0,r.kt)("p",null,"It's worth noting that assertions can be disabled at runtime using the -disableassertions or -da flag, so they should not be relied upon for critical program logic or security checks."),(0,r.kt)("h1",{id:"exception-handling"},"Exception Handling"),(0,r.kt)("p",null,"Exception handling is a mechanism in object-oriented programming that allows a program to handle runtime errors and unexpected events that can occur during the execution of a program. Exceptions are objects that represent errors, and they can be thrown by code that detects an error condition. When an exception is thrown, it is caught by a handler that can take appropriate actions, such as logging an error message, displaying a warning to the user, or attempting to recover from the error."),(0,r.kt)("p",null,"In Java, exceptions are handled through a try-catch block. The code that may throw an exception is enclosed within a try block, and any exceptions that are thrown are caught by one or more catch blocks. Each catch block specifies the type of exception it can handle, and the code within the block is executed if an exception of that type is thrown."),(0,r.kt)("p",null,"For example, consider the following Java code that reads a number from the user and attempts to convert it to an integer:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.Scanner;\n\npublic class Example {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print("Enter a number: ");\n        String input = scanner.nextLine();\n        try {\n            int number = Integer.parseInt(input);\n            System.out.println("The number is: " + number);\n        } catch (NumberFormatException e) {\n            System.err.println("Invalid input: " + input);\n        }\n    }\n}\n')),(0,r.kt)("p",null,"In this example, the parseInt method can throw a NumberFormatException if the input string is not a valid integer. This exception is caught by the catch block that follows the try block, and an error message is printed to the console. Without exception handling, the program would crash if the user entered an invalid input."),(0,r.kt)("p",null,"Exception handling is an important part of writing robust and reliable code, and it allows programs to recover gracefully from errors instead of crashing or behaving unpredictably."),(0,r.kt)("h1",{id:"throwing-exceptions"},"Throwing Exceptions"),(0,r.kt)("p",null,"Throwing an exception in Java is a way of signaling that an error or exceptional condition has occurred during the execution of a program. This can help improve the robustness and reliability of the program by allowing the program to gracefully handle errors and prevent them from causing the program to crash or produce incorrect results."),(0,r.kt)("p",null,"To throw an exception in Java, you first need to create an instance of the exception class that corresponds to the type of error you want to throw. For example, to signal that a file could not be found, you would create an instance of the FileNotFoundException class. You can then throw this exception using the throw keyword followed by the exception object. Here's an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'public void readFile(String filename) throws FileNotFoundException {\n    File file = new File(filename);\n    if (!file.exists()) {\n        throw new FileNotFoundException("File not found: " + filename);\n    }\n    // code to read file...\n}\n')),(0,r.kt)("p",null,"In this example, if the file does not exist, an instance of FileNotFoundException is created with a message indicating the name of the file that could not be found. This exception is then thrown using the throw keyword. The throws keyword in the method signature indicates that the method may throw this exception and that calling code must handle it accordingly."),(0,r.kt)("p",null,"When an exception is thrown, it interrupts the normal flow of execution and is passed up the call stack until it is caught by an appropriate catch block or until it reaches the top level of the program, at which point it will terminate the program."),(0,r.kt)("h1",{id:"function-interfaces"},"Function Interfaces"),(0,r.kt)("p",null,"In Java, a functional interface is an interface that contains only one abstract method. It is also known as a Single Abstract Method (SAM) interface. The purpose of a functional interface is to provide a way to define a single functionality that can be executed by lambda expressions."),(0,r.kt)("p",null,"Functional interfaces are used extensively in Java 8 and later versions for lambda expressions, method references, and the Stream API. The use of functional interfaces makes it possible to write concise and expressive code."),(0,r.kt)("p",null,"Here's an example of a functional interface in Java:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"@FunctionalInterface\npublic interface Converter<F, T> {\n    T convert(F from);\n}\n")),(0,r.kt)("p",null,"In this example, the Converter interface has a single abstract method convert that takes a parameter of type F and returns a value of type T. The @FunctionalInterface annotation is used to indicate that this interface is a functional interface."),(0,r.kt)("p",null,"Functional interfaces can be used with lambda expressions to provide an implementation for the abstract method. Here's an example of how to use the Converter interface with a lambda expression:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'Converter<String, Integer> converter = (from) -> Integer.valueOf(from);\nInteger result = converter.convert("123");\nSystem.out.println(result);    // Output: 123\n')),(0,r.kt)("p",null,"In this example, a lambda expression is used to provide an implementation for the convert method of the Converter interface. The lambda expression takes a String as a parameter and returns an Integer."),(0,r.kt)("p",null,"Functional interfaces provide a simple and powerful way to write code that is concise, expressive, and easy to read."),(0,r.kt)("h1",{id:"no-more-null"},"No more Null"),(0,r.kt)("p",null,'"No More Null" is a programming paradigm that aims to reduce the use of null references or null values in code. It\'s based on the idea that null references can cause bugs and make code harder to understand and maintain, especially in larger projects.'),(0,r.kt)("p",null,'Instead of using null references, the "No More Null" paradigm suggests using alternative solutions, such as:'),(0,r.kt)("p",null,"Optional types: Optional types are a way to represent values that may or may not be present. They allow you to explicitly handle cases where a value may be missing, instead of relying on null references."),(0,r.kt)("p",null,"Null object pattern: The null object pattern is a design pattern that suggests using a special object to represent the absence of a value. This object is designed to behave like a real object, but it doesn't contain any data."),(0,r.kt)("p",null,"Defensive programming: Defensive programming is a coding technique that involves anticipating and handling potential errors and edge cases. This can include things like checking for null references before using them, validating input, and adding error handling code to catch and handle exceptions."),(0,r.kt)("p",null,'By adopting the "No More Null" paradigm, developers can write more reliable and maintainable code, and reduce the likelihood of bugs caused by null references. However, it requires a shift in mindset and a willingness to use alternative solutions to handle cases where values may be missing.'),(0,r.kt)("h1",{id:"variable-capture"},"Variable Capture"),(0,r.kt)("p",null,"Variable capture is a concept in programming languages that refers to the ability of a closure (a function that references variables from its surrounding environment) to access and retain the values of those variables, even after the function that defined them has completed execution. The captured variables become part of the closure's state, and can be used or modified by any subsequent calls to the closure."),(0,r.kt)("p",null,"Variable capture is a useful feature in functional programming, as it allows for the creation of closures that can be used as callbacks or event handlers in asynchronous programming scenarios. By capturing the state of a particular context, the closure can maintain a consistent view of that context across multiple asynchronous calls, even as the state of the context changes."),(0,r.kt)("p",null,"Variable capture is supported in many programming languages, including JavaScript, Python, and C#. In languages that support closures, the process of variable capture is typically automatic and transparent to the programmer. However, it is important to be aware of the potential for variable capture to introduce unintended side effects or memory leaks, particularly in long-running applications or systems with many concurrent users."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def make_multiplier(x):\n    def multiplier(n):\n        return n * x\n    return multiplier\n\ndouble = make_multiplier(2)\nprint(double(5))  # Output: 10\n")),(0,r.kt)("p",null,"In this example, the make_multiplier function returns a nested function multiplier which captures the value of x in its enclosing scope. When we call make_multiplier(2) and assign the result to double, we create a new function that multiplies its argument by 2. When we call double(5), the value of x is still remembered and used to calculate the result."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <iostream>\n\nint main() {\n  int x = 2;\n  auto multiplier = [x](int n) { return n * x; };\n  std::cout << multiplier(5) << std::endl;  // Output: 10\n  return 0;\n}\n")),(0,r.kt)("p",null,"In C++, we can use lambda expressions to capture variables. In this example, we create a lambda expression that captures the value of x and returns a function that multiplies its argument by x. We then call this lambda with an argument of 5, which results in the value 10."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public class VariableCaptureExample {\n    public static void main(String[] args) {\n        int x = 2;\n        IntFunction<Integer> multiplier = n -> n * x;\n        System.out.println(multiplier.apply(5));  // Output: 10\n    }\n}\n")),(0,r.kt)("p",null,"In Java, we can use lambda expressions or method references to capture variables. In this example, we create an IntFunction that captures the value of x and returns a result based on its input. We then call this function with an argument of 5, which results in the value 10."))}d.isMDXComponent=!0}}]);