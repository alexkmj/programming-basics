"use strict";(self.webpackChunkprogramming_basics=self.webpackChunkprogramming_basics||[]).push([[393],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),c=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(o.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(n),h=r,m=d["".concat(o,".").concat(h)]||d[h]||p[h]||i;return n?a.createElement(m,l(l({ref:t},u),{},{components:n})):a.createElement(m,l({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=h;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s[d]="string"==typeof e?e:r,l[1]=s;for(var c=2;c<i;c++)l[c]=n[c];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},5162:(e,t,n)=>{n.d(t,{Z:()=>l});var a=n(7294),r=n(6010);const i={tabItem:"tabItem_Ymn6"};function l(e){let{children:t,hidden:n,className:l}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(i.tabItem,l),hidden:n},t)}},4866:(e,t,n)=>{n.d(t,{Z:()=>k});var a=n(7462),r=n(7294),i=n(6010),l=n(2466),s=n(6550),o=n(1980),c=n(7392),u=n(12);function d(e){return function(e){return r.Children.map(e,(e=>{if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:r}}=e;return{value:t,label:n,attributes:a,default:r}}))}function p(e){const{values:t,children:n}=e;return(0,r.useMemo)((()=>{const e=t??d(n);return function(e){const t=(0,c.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function h(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function m(e){let{queryString:t=!1,groupId:n}=e;const a=(0,s.k6)(),i=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,o._X)(i),(0,r.useCallback)((e=>{if(!i)return;const t=new URLSearchParams(a.location.search);t.set(i,e),a.replace({...a.location,search:t.toString()})}),[i,a])]}function b(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,i=p(e),[l,s]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!h({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:i}))),[o,c]=m({queryString:n,groupId:a}),[d,b]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,i]=(0,u.Nk)(n);return[a,(0,r.useCallback)((e=>{n&&i.set(e)}),[n,i])]}({groupId:a}),f=(()=>{const e=o??d;return h({value:e,tabValues:i})?e:null})();(0,r.useLayoutEffect)((()=>{f&&s(f)}),[f]);return{selectedValue:l,selectValue:(0,r.useCallback)((e=>{if(!h({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);s(e),c(e),b(e)}),[c,b,i]),tabValues:i}}var f=n(2389);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function v(e){let{className:t,block:n,selectedValue:s,selectValue:o,tabValues:c}=e;const u=[],{blockElementScrollPositionUntilNextRender:d}=(0,l.o5)(),p=e=>{const t=e.currentTarget,n=u.indexOf(t),a=c[n].value;a!==s&&(d(t),o(a))},h=e=>{let t=null;switch(e.key){case"Enter":p(e);break;case"ArrowRight":{const n=u.indexOf(e.currentTarget)+1;t=u[n]??u[0];break}case"ArrowLeft":{const n=u.indexOf(e.currentTarget)-1;t=u[n]??u[u.length-1];break}}t?.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":n},t)},c.map((e=>{let{value:t,label:n,attributes:l}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:s===t?0:-1,"aria-selected":s===t,key:t,ref:e=>u.push(e),onKeyDown:h,onClick:p},l,{className:(0,i.Z)("tabs__item",g.tabItem,l?.className,{"tabs__item--active":s===t})}),n??t)})))}function y(e){let{lazy:t,children:n,selectedValue:a}=e;if(n=Array.isArray(n)?n:[n],t){const e=n.find((e=>e.props.value===a));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},n.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function w(e){const t=b(e);return r.createElement("div",{className:(0,i.Z)("tabs-container",g.tabList)},r.createElement(v,(0,a.Z)({},e,t)),r.createElement(y,(0,a.Z)({},e,t)))}function k(e){const t=(0,f.Z)();return r.createElement(w,(0,a.Z)({key:String(t)},e))}},4708:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>o,default:()=>m,frontMatter:()=>s,metadata:()=>c,toc:()=>d});var a=n(7462),r=(n(7294),n(3905)),i=n(4866),l=n(5162);const s={sidebar_position:1},o="Abstraction",c={unversionedId:"abstraction",id:"abstraction",title:"Abstraction",description:"Abstraction refers to the process of hiding complexity and focusing on",source:"@site/docs/abstraction.mdx",sourceDirName:".",slug:"/abstraction",permalink:"/programming-basics/docs/abstraction",draft:!1,editUrl:"https://github.com/alexkmj/programming-basics/tree/master/docs/docs/abstraction.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",next:{title:"Encapsulation",permalink:"/programming-basics/docs/encapsulation"}},u={},d=[{value:"Data Abstraction",id:"data-abstraction",level:2},{value:"Procedural Abstraction",id:"procedural-abstraction",level:2}],p={toc:d},h="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(h,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"abstraction"},"Abstraction"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Abstraction")," refers to the process of hiding complexity and focusing on\nessential features of an object or system. There are several types of\nabstraction in object-oriented programming. They include ",(0,r.kt)("strong",{parentName:"p"},"data abstraction and\nprocedural abstraction"),"."),(0,r.kt)("h2",{id:"data-abstraction"},"Data Abstraction"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Data abstraction")," refers to the process of hiding implementation details and\nexposing only the relevant information to the user. In other words, data\nabstraction is the process of representing complex data structures in a\nsimplified way, by defining a set of operations that can be performed on that\ndata without exposiong the underlying implementation."),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'abstract class Shape {\n    public abstract double area();\n    public abstract double perimeter();\n}\n\nclass Rectangle extends Shape {\n    private double width;\n    private double height;\n\n    public Rectangle(double width, double height) {\n        this.width = width;\n        this.height = height;\n    }\n\n    @Override\n    public double area() {\n        return width * height;\n    }\n\n    @Override\n    public double perimeter() {\n        return 2 * (width + height);\n    }\n}\n\nclass Circle extends Shape {\n    private double radius;\n\n    public Circle(double radius) {\n        this.radius = radius;\n    }\n\n    @Override\n    public double area() {\n        return Math.PI * radius * radius;\n    }\n\n    @Override\n    public double perimeter() {\n        return 2 * Math.PI * radius;\n    }\n}\n\npublic class ShapeDemo {\n    public static void main(String[] args) {\n        Shape rect = new Rectangle(5, 10);\n        Shape circle = new Circle(7);\n\n        System.out.println("Rectangle area: " + rect.area());\n        System.out.println("Rectangle perimeter: " + rect.perimeter());\n\n        System.out.println("Circle area: " + circle.area());\n        System.out.println("Circle perimeter: " + circle.perimeter());\n    }\n}\n'))),(0,r.kt)(l.Z,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\n\n#include <math.h>\n\nusing namespace std;\n\nclass Shape {\n    public: virtual double area() = 0;\n    virtual double perimeter() = 0;\n};\n\nclass Rectangle: public Shape {\nprivate:\n    double width;\n    double height;\n\npublic:\n    Rectangle(double width, double height): width(width), height(height) {}\n\n    double area() {\n        return width * height;\n    }\n\n    double perimeter() {\n        return 2 * (width + height);\n    }\n};\n\nclass Circle: public Shape {\nprivate:\n    double radius;\n\npublic:\n    Circle(double radius): radius(radius) {}\n\n    double area() {\n        return M_PI * radius * radius;\n    }\n\n    double perimeter() {\n        return 2 * M_PI * radius;\n    }\n};\n\nint main() {\n    Rectangle rect(5, 10);\n    Circle circle(7);\n\n    std::cout << "Rectangle area: " << rect.area() << std::endl;\n    std::cout << "Rectangle perimeter: " << rect.perimeter() << std::endl;\n\n    std::cout << "Circle area: " << circle.area() << std::endl;\n    std::cout << "Circle perimeter: " << circle.perimeter() << std::endl;\n\n    return 0;\n}\n'))),(0,r.kt)(l.Z,{value:"python",label:"Python",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'from abc import ABC, abstractmethod\n\nclass Shape(ABC):\n    @abstractmethod\n    def area(self):\n        pass\n\n    @abstractmethod\n    def perimeter(self):\n        pass\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n\n    def area(self):\n        return self.width * self.height\n\n    def perimeter(self):\n        return 2 * (self.width + self.height)\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        self.radius = radius\n\n    def area(self):\n        return math.pi * self.radius ** 2\n\n    def perimeter(self):\n        return 2 * math.pi * self.radius\n\nif __name__ == "__main__":\n    rect = Rectangle(5, 10)\n    circle = Circle(7)\n\n    print("Rectangle area:", rect.area())\n    print("Rectangle perimeter:", rect.perimeter())\n\n    print("Circle area:", circle.area())\n    print("Circle perimeter:", circle.perimeter())\n')),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"In Python, the ABC (Abstract Base Class) is a special class provided by the abc\nmodule, which is used for defining abstract base classes. An abstract base class\nis a class that cannot be instantiated directly, but can be used as a base class\nfor other classes.")))),(0,r.kt)("p",null,"In this example, we define an abstract class ",(0,r.kt)("inlineCode",{parentName:"p"},"Shape")," with two abstract methods\n",(0,r.kt)("inlineCode",{parentName:"p"},"area()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"paremiter()"),". Any class that inherits from ",(0,r.kt)("inlineCode",{parentName:"p"},"Shape")," must implement\nthese methods. This is an example of data abstraction, since we have defined a\nhigh-level interface that does not expose the implementation details of each\nshape."),(0,r.kt)("p",null,"We then define two concrete subclasses, ",(0,r.kt)("inlineCode",{parentName:"p"},"Rectangle")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Circle"),", that inherit\nfrom ",(0,r.kt)("inlineCode",{parentName:"p"},"Shape")," and implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"area()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"perimeter()")," methods. Each subclass\nhas its own unique implementation of these methods that reflects the attributes\nand behaviors of rectangles and circles."),(0,r.kt)("p",null,"By using data abstraction in this way, we can create a clean and well-defined\ninterface for working with different types of shapes, without exposing the\nlower-level implementation details of each shape to the user."),(0,r.kt)("h2",{id:"procedural-abstraction"},"Procedural Abstraction"),(0,r.kt)("p",null,"Also known as ",(0,r.kt)("strong",{parentName:"p"},"Function Abstraction"),".\nThis refers to the process of hiding the implementation details of a method or\nfunction and exposing only its interface or signature. In other words, one\nshould only need to know what the method does and what arguments it takes,\nwithout needing to understand how it works internally."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'public class Calculator {\n    public static int add(int a, int b) {\n        return a + b;\n    }\n    \n    public static int subtract(int a, int b) {\n        return a - b;\n    }\n    \n    public static int multiply(int a, int b) {\n        return a * b;\n    }\n    \n    public static double divide(double a, double b) {\n        if (b == 0) {\n            throw new IllegalArgumentException("Cannot divide by zero");\n        }\n        return a / b;\n    }\n}\n')),(0,r.kt)("p",null,"In this example, we define a class ",(0,r.kt)("inlineCode",{parentName:"p"},"Calculator")," which provides several methods\nfor performing basic arithmetic operations."),(0,r.kt)("p",null,"For example, the ",(0,r.kt)("inlineCode",{parentName:"p"},"add()")," method takes two integers and returns their sum. The\nuser does not need to know how the addition was performed, only that the method\nwould return the correct result."))}m.isMDXComponent=!0}}]);