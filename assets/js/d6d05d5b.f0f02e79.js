"use strict";(self.webpackChunkprogramming_basics=self.webpackChunkprogramming_basics||[]).push([[538],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>h});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),u=p(a),d=r,h=u["".concat(l,".").concat(d)]||u[d]||m[d]||i;return a?n.createElement(h,s(s({ref:t},c),{},{components:a})):n.createElement(h,s({ref:t},c))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,s=new Array(i);s[0]=d;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[u]="string"==typeof e?e:r,s[1]=o;for(var p=2;p<i;p++)s[p]=a[p];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},5162:(e,t,a)=>{a.d(t,{Z:()=>s});var n=a(7294),r=a(6010);const i={tabItem:"tabItem_Ymn6"};function s(e){let{children:t,hidden:a,className:s}=e;return n.createElement("div",{role:"tabpanel",className:(0,r.Z)(i.tabItem,s),hidden:a},t)}},4866:(e,t,a)=>{a.d(t,{Z:()=>w});var n=a(7462),r=a(7294),i=a(6010),s=a(2466),o=a(6550),l=a(1980),p=a(7392),c=a(12);function u(e){return function(e){return r.Children.map(e,(e=>{if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:t,label:a,attributes:n,default:r}}=e;return{value:t,label:a,attributes:n,default:r}}))}function m(e){const{values:t,children:a}=e;return(0,r.useMemo)((()=>{const e=t??u(a);return function(e){const t=(0,p.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,a])}function d(e){let{value:t,tabValues:a}=e;return a.some((e=>e.value===t))}function h(e){let{queryString:t=!1,groupId:a}=e;const n=(0,o.k6)(),i=function(e){let{queryString:t=!1,groupId:a}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return a??null}({queryString:t,groupId:a});return[(0,l._X)(i),(0,r.useCallback)((e=>{if(!i)return;const t=new URLSearchParams(n.location.search);t.set(i,e),n.replace({...n.location,search:t.toString()})}),[i,n])]}function g(e){const{defaultValue:t,queryString:a=!1,groupId:n}=e,i=m(e),[s,o]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!d({value:t,tabValues:a}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${a.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const n=a.find((e=>e.default))??a[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:i}))),[l,p]=h({queryString:a,groupId:n}),[u,g]=function(e){let{groupId:t}=e;const a=function(e){return e?`docusaurus.tab.${e}`:null}(t),[n,i]=(0,c.Nk)(a);return[n,(0,r.useCallback)((e=>{a&&i.set(e)}),[a,i])]}({groupId:n}),f=(()=>{const e=l??u;return d({value:e,tabValues:i})?e:null})();(0,r.useLayoutEffect)((()=>{f&&o(f)}),[f]);return{selectedValue:s,selectValue:(0,r.useCallback)((e=>{if(!d({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);o(e),p(e),g(e)}),[p,g,i]),tabValues:i}}var f=a(2389);const y={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function b(e){let{className:t,block:a,selectedValue:o,selectValue:l,tabValues:p}=e;const c=[],{blockElementScrollPositionUntilNextRender:u}=(0,s.o5)(),m=e=>{const t=e.currentTarget,a=c.indexOf(t),n=p[a].value;n!==o&&(u(t),l(n))},d=e=>{let t=null;switch(e.key){case"Enter":m(e);break;case"ArrowRight":{const a=c.indexOf(e.currentTarget)+1;t=c[a]??c[0];break}case"ArrowLeft":{const a=c.indexOf(e.currentTarget)-1;t=c[a]??c[c.length-1];break}}t?.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":a},t)},p.map((e=>{let{value:t,label:a,attributes:s}=e;return r.createElement("li",(0,n.Z)({role:"tab",tabIndex:o===t?0:-1,"aria-selected":o===t,key:t,ref:e=>c.push(e),onKeyDown:d,onClick:m},s,{className:(0,i.Z)("tabs__item",y.tabItem,s?.className,{"tabs__item--active":o===t})}),a??t)})))}function k(e){let{lazy:t,children:a,selectedValue:n}=e;if(a=Array.isArray(a)?a:[a],t){const e=a.find((e=>e.props.value===n));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},a.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==n}))))}function v(e){const t=g(e);return r.createElement("div",{className:(0,i.Z)("tabs-container",y.tabList)},r.createElement(b,(0,n.Z)({},e,t)),r.createElement(k,(0,n.Z)({},e,t)))}function w(e){const t=(0,f.Z)();return r.createElement(v,(0,n.Z)({key:String(t)},e))}},5973:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var n=a(7462),r=(a(7294),a(3905));a(4866),a(5162);const i={sidebar_position:7},s="Generics",o={unversionedId:"oop/generics",id:"oop/generics",title:"Generics",description:"Generics is a feature in Object-Oriented Programming (OOP) that allows for the",source:"@site/docs/oop/generics.mdx",sourceDirName:"oop",slug:"/oop/generics",permalink:"/programming-basics/docs/oop/generics",draft:!1,editUrl:"https://github.com/alexkmj/programming-basics/tree/master/docs/docs/oop/generics.mdx",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"sidebar",previous:{title:"SOLID Principles",permalink:"/programming-basics/docs/oop/solid"},next:{title:"No More Null",permalink:"/programming-basics/docs/oop/no-more-null"}},l={},p=[{value:"Wildcards",id:"wildcards",level:2},{value:"Generics in Static Methods",id:"generics-in-static-methods",level:2},{value:"The Diamond Operator",id:"the-diamond-operator",level:2},{value:"Wrapper Classes",id:"wrapper-classes",level:2},{value:"Generic subtypes",id:"generic-subtypes",level:2},{value:"Generic Type and Parameterised Type",id:"generic-type-and-parameterised-type",level:2},{value:"Bounded Wildcards",id:"bounded-wildcards",level:2},{value:"Raw types",id:"raw-types",level:2},{value:"Type Erasure",id:"type-erasure",level:2}],c={toc:p},u="wrapper";function m(e){let{components:t,...a}=e;return(0,r.kt)(u,(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"generics"},"Generics"),(0,r.kt)("p",null,"Generics is a feature in Object-Oriented Programming (OOP) that allows for the\ncreation of classes, interfaces, and methods that can work with any type of\nobject. It provides a way to write reusable code and improve type safety by\nallowing classes and methods to be parameterized with types."),(0,r.kt)("p",null,"Generics provide a way to create type-safe code, which means that the code is\ndesigned to catch errors at compile-time rather than at runtime. With generics,\nyou can write code that works with any type of object without sacrificing type\nsafety."),(0,r.kt)("p",null,"The most common use of generics is to create collections, such as ",(0,r.kt)("inlineCode",{parentName:"p"},"ArrayList"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},"HashSet"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"LinkedList"),", that can hold any type of object. By using\ngenerics, you can write a single implementation of a collection that can be used\nto store and retrieve objects of any type, rather than having to write a\nseparate implementation for each type of object."),(0,r.kt)("p",null,"Generics are supported by many programming languages, including Java, C#, and\nPython. They are an important tool for developers who want to write reusable,\ntype-safe code that can work with any type of object."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.ArrayList;\n\npublic class Example {\n  public static void main(String[] args) {\n    ArrayList<String> list = new ArrayList<String>();\n    list.add("Hello");\n    list.add("World");\n    list.add("!");\n\n    for (String str : list) {\n      System.out.println(str);\n    }\n  }\n}\n')),(0,r.kt)("p",null,"In this example, we're creating an ",(0,r.kt)("inlineCode",{parentName:"p"},"ArrayList")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"String")," objects. The\n",(0,r.kt)("inlineCode",{parentName:"p"},"ArrayList")," class is a generic class, and we're specifying that we want to store\n",(0,r.kt)("inlineCode",{parentName:"p"},"String")," objects by putting ",(0,r.kt)("inlineCode",{parentName:"p"},"<String>")," after the class name. We then add three\n",(0,r.kt)("inlineCode",{parentName:"p"},"String")," objects to the list, and use a for loop to iterate over the list and\nprint out each ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),". Because we've specified that the list can only contain\n",(0,r.kt)("inlineCode",{parentName:"p"},"String")," objects, we can be sure that the for loop will only encounter ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),"\nobjects and won't throw any type errors."),(0,r.kt)("h2",{id:"wildcards"},"Wildcards"),(0,r.kt)("p",null,'In Java Generics, a wildcard refers to the use of the question mark symbol "?" as a type argument when defining a generic class, method or interface. It allows you to create a more flexible and generalizable code that can accept different types of parameters at runtime.'),(0,r.kt)("p",null,"Wildcards can be used in three different ways:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Unbounded Wildcards",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-java"},"List<?> list = new ArrayList<>();\n"))),(0,r.kt)("li",{parentName:"ul"},"Upper-bounded Wildcards",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-java"},"List<? extends Number> list = new ArrayList<Integer>();\n"))),(0,r.kt)("li",{parentName:"ul"},"Lower-bounded Wildcards",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-java"},"List<? super Integer> list = new ArrayList<Number>();\n")))),(0,r.kt)("p",null,"Wildcards are useful when you want to write code that can work with different types of objects without knowing their exact types at compile time. They can help you to create more flexible and reusable code. However, they should be used with care because they can make your code more complex and harder to understand."),(0,r.kt)("h2",{id:"generics-in-static-methods"},"Generics in Static Methods"),(0,r.kt)("p",null,"Generics can also be used in static methods in Java. When a static method is generic, the type parameter must be declared before the return type of the method. This allows the method to use the type parameter in its arguments or return type."),(0,r.kt)("p",null,"Here's an example of a generic static method that takes an array of any type and returns the maximum element:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public static <T extends Comparable<T>> T findMax(T[] arr) {\n    T max = arr[0];\n    for (int i = 1; i < arr.length; i++) {\n        if (arr[i].compareTo(max) > 0) {\n            max = arr[i];\n        }\n    }\n    return max;\n}\n")),(0,r.kt)("p",null,"In this example, the type parameter ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," is bounded by ",(0,r.kt)("inlineCode",{parentName:"p"},"Comparable<T>"),", which means that T must be a type that implements the Comparable interface. The method then initializes max to the first element of the array and iterates through the rest of the array to find the maximum element. Finally, it returns the maximum element."),(0,r.kt)("p",null,"The method can be called with any array of Comparable elements, like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'Integer[] intArr = {1, 2, 3};\nInteger maxInt = findMax(intArr);\nSystem.out.println("Max integer: " + maxInt);\n\nString[] strArr = {"apple", "banana", "cherry"};\nString maxStr = findMax(strArr);\nSystem.out.println("Max string: " + maxStr);\n')),(0,r.kt)("p",null,"In this example, the findMax method is called with an array of Integer elements and an array of String elements, and it returns the maximum element of each array."),(0,r.kt)("h2",{id:"the-diamond-operator"},"The Diamond Operator"),(0,r.kt)("p",null,"The diamond operator ",(0,r.kt)("inlineCode",{parentName:"p"},"<>")," is a feature in Java introduced in Java 7. It provides a simplified syntax for creating an instance of a parameterized class by allowing the compiler to infer the type arguments from the context."),(0,r.kt)("p",null,"Prior to the diamond operator, when creating an instance of a parameterized class, it was necessary to specify the type arguments twice - once when declaring the variable and again when creating the instance, like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"List<String> myList = new ArrayList<String>();\n")),(0,r.kt)("p",null,"With the diamond operator, the second declaration of type arguments can be replaced with an empty set of angle brackets, like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"List<String> myList = new ArrayList<>();\n")),(0,r.kt)("p",null,"The diamond operator can be used with any type of parameterized class, including nested parameterized classes and anonymous inner classes."),(0,r.kt)("p",null,"One important thing to note is that the diamond operator can only be used when the type arguments can be inferred from the context, so it cannot be used with constructors that do not have any arguments or with constructors that have arguments of different types. In those cases, the type arguments must still be explicitly specified."),(0,r.kt)("h2",{id:"wrapper-classes"},"Wrapper Classes"),(0,r.kt)("p",null,"In Java, primitive types (such as int, float, double, etc.) are not objects and do not belong to a class hierarchy. However, sometimes it is necessary to treat these primitives as objects, for example, when they need to be passed as an argument to a method that requires an object, or when they need to be stored in a collection."),(0,r.kt)("p",null,"To solve this problem, Java provides a set of wrapper classes, which are classes that wrap the primitive types and provide a way to treat them as objects. The wrapper classes are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Boolean for the boolean primitive type"),(0,r.kt)("li",{parentName:"ul"},"Byte for the byte primitive type"),(0,r.kt)("li",{parentName:"ul"},"Short for the short primitive type"),(0,r.kt)("li",{parentName:"ul"},"Integer for the int primitive type"),(0,r.kt)("li",{parentName:"ul"},"Long for the long primitive type"),(0,r.kt)("li",{parentName:"ul"},"Float for the float primitive type"),(0,r.kt)("li",{parentName:"ul"},"Double for the double primitive type"),(0,r.kt)("li",{parentName:"ul"},"Character for the char primitive type"),(0,r.kt)("li",{parentName:"ul"},"Wrapper classes provide a set of methods that allow you to convert between the primitive type and the wrapper object. For example, you can use the intValue() method of the Integer class to get the int value of an Integer object.")),(0,r.kt)("p",null,"Wrapper classes are also useful when you need to store primitive types in collections, as collections can only store objects. For example, you can use an ",(0,r.kt)("inlineCode",{parentName:"p"},"ArrayList<Integer>")," to store a list of integers."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'int myInt = 42;\nInteger myInteger = Integer.valueOf(myInt); // create an Integer object from the int value\nint myInt2 = myInteger.intValue(); // get the int value from the Integer object\nSystem.out.println("myInt2 = " + myInt2); // prints "myInt2 = 42"\n')),(0,r.kt)("h2",{id:"generic-subtypes"},"Generic subtypes"),(0,r.kt)("p",null,"In Java, generic subtypes are a way to provide a more specific type argument to a generic class or method. This is achieved by defining a new generic class or method that extends or implements an existing one, but with a more specific type argument."),(0,r.kt)("p",null,"For example, suppose we have a generic class ",(0,r.kt)("inlineCode",{parentName:"p"},"Box<T>")," that can hold any type of object, and we want to create a new class StringBox that can only hold strings. We can define StringBox as a subtype of ",(0,r.kt)("inlineCode",{parentName:"p"},"Box<String>"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public class Box<T> {\n    private T item;\n\n    public void set(T item) {\n        this.item = item;\n    }\n\n    public T get() {\n        return item;\n    }\n}\n\npublic class StringBox extends Box<String> {\n    // This class inherits all the methods of Box<String>,\n    // but can only hold String objects\n}\n")),(0,r.kt)("p",null,"Now we can create a StringBox object and use it to hold a string:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'StringBox box = new StringBox();\nbox.set("hello");\nString s = box.get();  // This is guaranteed to be a String\n')),(0,r.kt)("p",null,"Similarly, we can define a new generic method that is a subtype of an existing one, but with a more specific type argument. For example, suppose we have a generic method ",(0,r.kt)("inlineCode",{parentName:"p"},"printList(List<T> list)")," that can print any list of objects, and we want to create a new method ",(0,r.kt)("inlineCode",{parentName:"p"},"printStringList(List<String> list)")," that can only print lists of strings. We can define printStringList as a subtype of printList:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public static <T> void printList(List<T> list) {\n    for (T item : list) {\n        System.out.println(item);\n    }\n}\n\npublic static void printStringList(List<String> list) {\n    // This method is a subtype of printList(List<T>),\n    // but with T fixed to String\n    printList(list);\n}\n")),(0,r.kt)("p",null,"Now we can use printStringList to print a list of strings:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'List<String> strings = Arrays.asList("hello", "world");\nprintStringList(strings);\n')),(0,r.kt)("h2",{id:"generic-type-and-parameterised-type"},"Generic Type and Parameterised Type"),(0,r.kt)("p",null,"In Java, a generic type is a generic class or interface that has one or more type parameters. A type parameter is a placeholder for a type that will be specified when an instance of the generic type is created. For example, the List interface is a generic type with a single type parameter that specifies the type of elements it contains:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public interface List<E> {\n    void add(E element);\n    E get(int index);\n}\n")),(0,r.kt)("p",null,"Here, E is a type parameter that represents the element type of the list. When a List instance is created, the type parameter is specified:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'List<String> strings = new ArrayList<>();\nstrings.add("Hello");\nString s = strings.get(0);\n')),(0,r.kt)("p",null,"In this example, strings is an instance of ArrayList that contains String elements."),(0,r.kt)("p",null,"A parameterized type is a concrete type that is created by specifying actual type arguments for the type parameters of a generic type. For example, ",(0,r.kt)("inlineCode",{parentName:"p"},"ArrayList<String>")," is a parameterized type that is created by specifying String as the actual type argument for the E type parameter of the List interface."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"List<String> strings = new ArrayList<>();\n")),(0,r.kt)("p",null,"Here, ",(0,r.kt)("inlineCode",{parentName:"p"},"ArrayList<String>")," is a parameterized type that implements the ",(0,r.kt)("inlineCode",{parentName:"p"},"List<String>")," interface."),(0,r.kt)("h2",{id:"bounded-wildcards"},"Bounded Wildcards"),(0,r.kt)("p",null,"Bounded wildcards are a feature in Java generics that allow you to restrict the type of parameter that can be passed to a generic type. This can be useful when you want to enforce a certain relationship between the types."),(0,r.kt)("p",null,"A bounded wildcard is defined using the ? wildcard character followed by an upper or lower bound. An upper bound is specified using the extends keyword, while a lower bound is specified using the super keyword."),(0,r.kt)("p",null,"For example, consider the following class hierarchy:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"class Animal {}\nclass Mammal extends Animal {}\nclass Dog extends Mammal {}\n")),(0,r.kt)("p",null,"If you have a method that takes a list of animals and you want to restrict it to only take lists of mammals or their subtypes, you can use a bounded wildcard with an upper bound:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public void doSomething(List<? extends Mammal> mammals) {\n    // do something\n}\n")),(0,r.kt)("p",null,"In this case, ",(0,r.kt)("inlineCode",{parentName:"p"},"List<? extends Mammal>"),' means "a list of any type that is a subtype of Mammal". This allows you to pass in a ',(0,r.kt)("inlineCode",{parentName:"p"},"List<Mammal>")," or a ",(0,r.kt)("inlineCode",{parentName:"p"},"List<Dog>")," to the method, but not a ",(0,r.kt)("inlineCode",{parentName:"p"},"List<Animal>"),"."),(0,r.kt)("p",null,"If you want to restrict the type parameter to be a super type of a certain type, you can use a bounded wildcard with a lower bound:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public void doSomething(List<? super Mammal> mammals) {\n    // do something\n}\n")),(0,r.kt)("p",null,"In this case, ",(0,r.kt)("inlineCode",{parentName:"p"},"List<? super Mammal>"),' means "a list of any type that is a supertype of Mammal". This allows you to pass in a ',(0,r.kt)("inlineCode",{parentName:"p"},"List<Animal>")," or a ",(0,r.kt)("inlineCode",{parentName:"p"},"List<Object>")," to the method, but not a ",(0,r.kt)("inlineCode",{parentName:"p"},"List<Dog>")),(0,r.kt)("h2",{id:"raw-types"},"Raw types"),(0,r.kt)("p",null,"In Java, a raw type is a reference to a generic class or interface without providing the required type parameter. It can be used in situations where the type parameter is unknown or irrelevant. However, using raw types can result in potential errors and is generally not recommended."),(0,r.kt)("p",null,"For example, consider the following generic class:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public class Box<T> {\n    private T t;\n\n    public void set(T t) {\n        this.t = t;\n    }\n\n    public T get() {\n        return t;\n    }\n}\n")),(0,r.kt)("p",null,"If we create an instance of Box without providing a type parameter, it becomes a raw type:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"Box box = new Box();\n")),(0,r.kt)("p",null,"Now, any object can be added to the box, regardless of its type, and the type safety of the generic class is lost:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'box.set("Hello");\nInteger i = (Integer) box.get(); // Causes ClassCastException at runtime\n')),(0,r.kt)("p",null,"In this example, the set method is called with a string, but the get method is called with an integer, causing a ClassCastException at runtime."),(0,r.kt)("p",null,"To avoid this issue, it is recommended to always provide a type parameter when using generic classes and interfaces in Java."),(0,r.kt)("h2",{id:"type-erasure"},"Type Erasure"),(0,r.kt)("p",null,"Type erasure is a process used in Java and other programming languages with generics to implement generic types. It allows the use of generic types without sacrificing performance or type safety at runtime."),(0,r.kt)("p",null,'In Java, generics are implemented using type erasure, which means that the generic type information is removed (or "erased") at runtime. This is done to maintain backward compatibility with code written before the introduction of generics in Java.'),(0,r.kt)("p",null,"During compilation, the compiler replaces all generic type parameters with their upper bounds or Object if no bound is specified. For example, if we have a generic class ",(0,r.kt)("inlineCode",{parentName:"p"},"MyList<T>")," and instantiate it with ",(0,r.kt)("inlineCode",{parentName:"p"},"MyList<Integer>"),", the compiler replaces T with Integer and produces the code as if it was written with Integer instead of T."),(0,r.kt)("p",null,"At runtime, the compiled code behaves as if it was written without generics. This means that generic type information is not available at runtime, and all instances of the generic type are treated as if they are of the same raw type. This can lead to some unexpected behavior, such as runtime errors or incorrect type casting."),(0,r.kt)("p",null,"To summarize, type erasure is a technique used in Java to implement generics that involves replacing generic type parameters with their upper bounds or Object during compilation, and removing generic type information at runtime."),(0,r.kt)("h1",{id:"variable-capture"},"Variable Capture"),(0,r.kt)("p",null,"Variable capture is a concept in programming languages that refers to the ability of a closure (a function that references variables from its surrounding environment) to access and retain the values of those variables, even after the function that defined them has completed execution. The captured variables become part of the closure's state, and can be used or modified by any subsequent calls to the closure."),(0,r.kt)("p",null,"Variable capture is a useful feature in functional programming, as it allows for the creation of closures that can be used as callbacks or event handlers in asynchronous programming scenarios. By capturing the state of a particular context, the closure can maintain a consistent view of that context across multiple asynchronous calls, even as the state of the context changes."),(0,r.kt)("p",null,"Variable capture is supported in many programming languages, including JavaScript, Python, and C#. In languages that support closures, the process of variable capture is typically automatic and transparent to the programmer. However, it is important to be aware of the potential for variable capture to introduce unintended side effects or memory leaks, particularly in long-running applications or systems with many concurrent users."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def make_multiplier(x):\n    def multiplier(n):\n        return n * x\n    return multiplier\n\ndouble = make_multiplier(2)\nprint(double(5))  # Output: 10\n")),(0,r.kt)("p",null,"In this example, the make_multiplier function returns a nested function multiplier which captures the value of x in its enclosing scope. When we call make_multiplier(2) and assign the result to double, we create a new function that multiplies its argument by 2. When we call double(5), the value of x is still remembered and used to calculate the result."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <iostream>\n\nint main() {\n  int x = 2;\n  auto multiplier = [x](int n) { return n * x; };\n  std::cout << multiplier(5) << std::endl;  // Output: 10\n  return 0;\n}\n")),(0,r.kt)("p",null,"In C++, we can use lambda expressions to capture variables. In this example, we create a lambda expression that captures the value of x and returns a function that multiplies its argument by x. We then call this lambda with an argument of 5, which results in the value 10."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public class VariableCaptureExample {\n    public static void main(String[] args) {\n        int x = 2;\n        IntFunction<Integer> multiplier = n -> n * x;\n        System.out.println(multiplier.apply(5));  // Output: 10\n    }\n}\n")),(0,r.kt)("p",null,"In Java, we can use lambda expressions or method references to capture variables. In this example, we create an IntFunction that captures the value of x and returns a result based on its input. We then call this function with an argument of 5, which results in the value 10."),(0,r.kt)("h1",{id:"function-interfaces"},"Function Interfaces"),(0,r.kt)("p",null,"In Java, a functional interface is an interface that contains only one abstract\nmethod. It is also known as a Single Abstract Method (SAM) interface. The\npurpose of a functional interface is to provide a way to define a single\nfunctionality that can be executed by lambda expressions."),(0,r.kt)("p",null,"Functional interfaces are used extensively in Java 8 and later versions for\nlambda expressions, method references, and the Stream API. The use of functional\ninterfaces makes it possible to write concise and expressive code."),(0,r.kt)("p",null,"Here's an example of a functional interface in Java:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"@FunctionalInterface\npublic interface Converter<F, T> {\n    T convert(F from);\n}\n")),(0,r.kt)("p",null,"In this example, the ",(0,r.kt)("inlineCode",{parentName:"p"},"Converter")," interface has a single abstract method convert\nthat takes a parameter of type ",(0,r.kt)("inlineCode",{parentName:"p"},"F")," and returns a value of type ",(0,r.kt)("inlineCode",{parentName:"p"},"T"),". The\n",(0,r.kt)("inlineCode",{parentName:"p"},"@FunctionalInterface")," annotation is used to indicate that this interface is a\nfunctional interface."),(0,r.kt)("p",null,"Functional interfaces can be used with lambda expressions to provide an\nimplementation for the abstract method. Here's an example of how to use the\n",(0,r.kt)("inlineCode",{parentName:"p"},"Converter")," interface with a lambda expression:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'Converter<String, Integer> converter = (from) -> Integer.valueOf(from);\nInteger result = converter.convert("123");\nSystem.out.println(result);    // Output: 123\n')),(0,r.kt)("p",null,"In this example, a lambda expression is used to provide an implementation for\nthe convert method of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Converter")," interface. The lambda expression takes a\nString as a parameter and returns an Integer."),(0,r.kt)("p",null,"Functional interfaces provide a simple and powerful way to write code that is\nconcise, expressive, and easy to read."))}m.isMDXComponent=!0}}]);